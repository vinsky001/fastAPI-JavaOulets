from fastapi import FastAPI
from app.database import init_db, run_db_operation
import json
from fastapi import status
from contextlib import asynccontextmanager
from datetime import datetime, timezone
from fastapi import HTTPException
from app.schema import (
    JavaOutlet,
    JavaOutletCreate,
    JavaOutletList,
    JavaOutletMenuItem,
    JavaOutletMenuItemCreate,
    JavaOutletOrder,
    JavaOutletOrderCreate,
    JavaOutletOrderSummary,
    JavaOutletWithMenu,
)

@asynccontextmanager
async def lifespan(app: FastAPI) -> None:
    await init_db()
    yield
    
    

app = FastAPI(lifespan=lifespan,
    title="JavaHouse Coffee Kenya Outlets API",
    description=(
        "APIs for managing JavaHouse Coffee Kenya outlets, catalog items, and orders."
    ),
    version="0.2.0",
)    

@app.get("/", response_model=dict)
def service_overview() -> dict:
    return {
        "service": "JavaHouse Coffee Kenya Outlets",
        "version": "0.2.0",
        "status": "ok",
    }
    
@app.get("/outlets/", response_model=JavaOutletList)
async def list_java_outlets() -> JavaOutletList:
    """Lists all Javahouse Coffee Kenya Outlets"""
    try:
        rows = await run_db_operation(
        lambda connection: connection.execute("SELECT * FROM java_outlets ORDER BY name").mappings().all()
    ) 
    
        outlets = [dict(row) for row in rows]
        return JavaOutletList(outlets=outlets)    
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    
@app.post(
    "/outlets/",
    response_model=JavaOutlet,
    status_code=status.HTTP_201_CREATED,
    summary="Create a new JavaHouse outlet",
    description="Creates a new JavaHouse Coffee Kenya outlet with the provided details. The outlet ID and last inspection timestamp are automatically generated by the database."
)
async def create_java_outlet(payload: JavaOutletCreate) -> JavaOutlet:
    """
    Creates a new JavaHouse Coffee Kenya Outlet.
    
    Required fields:
    - name: Name of the outlet
    - location: Location/area of the outlet
    - city: City where the outlet is located
    - county: County/administrative region
    - is_open: Whether the outlet is currently open (1 or 0)
    
    Optional fields:
    - street_address: Street address of the outlet
    - phone_number: Contact phone number
    - rating: Customer rating (float)
    - opening_time: Opening time (e.g., "06:00")
    - closing_time: Closing time (e.g., "20:00")
    
    The `last_inspected_at` timestamp is automatically set by the database to the current UTC time.
    
    Returns: The created outlet with all fields including the database-generated ID and timestamp.
    """
    try:
        # Insert the outlet with datetime as native type
        async def _insert_outlet(session):
            await session.execute(
                """
                INSERT INTO java_outlets (
                    name, location, city, county, street_address, phone_number,
                    rating, is_open, opening_time, closing_time, last_inspected_at
                )
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """,
                (
                    payload.name,
                    payload.location,
                    payload.city,
                    payload.county,
                    payload.street_address,
                    payload.phone_number,
                    payload.rating,
                    payload.is_open,
                    payload.opening_time,
                    payload.closing_time,
                    datetime.now(timezone.utc),
                )
            )
        
        await run_db_operation(_insert_outlet)
        
        # Fetch the inserted outlet with actual DB values
        async def _fetch_outlet(session):
            return await session.execute(
                "SELECT * FROM java_outlets ORDER BY id DESC LIMIT 1"
            ).mappings().first()
        
        created_outlet = await run_db_operation(_fetch_outlet)
        
        if created_outlet is None:
            raise HTTPException(status_code=500, detail="Failed to retrieve created outlet")
        
        # Convert RowMapping to dict for Pydantic validation
        outlet_data = dict(created_outlet)
        
        return JavaOutlet(**outlet_data)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error creating a new outlet: {str(e)}")